import { createServer } from 'http';
import { Server } from 'socket.io';

const PORT = process.env.PORT || 3001;

// CrÃ©er le serveur HTTP
const httpServer = createServer((req, res) => {
  // Endpoint de santÃ©
  if (req.url === '/health') {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ status: 'ok', timestamp: new Date().toISOString() }));
    return;
  }
  res.writeHead(404);
  res.end('Not Found');
});

// Configurer Socket.IO
const io = new Server(httpServer, {
  cors: {
    origin: [
      'http://148.113.205.209:5173',
      'http://148.113.205.209:3000',
      'http://148.113.205.209:5173',
      // Ajouter vos domaines de production ici
      /\.netlify\.app$/,
      /\.same\.new$/,
    ],
    methods: ['GET', 'POST'],
    credentials: true,
  },
  transports: ['websocket', 'polling'],
});

// ============================================
// Ã‰tat du serveur
// ============================================
const connectedUsers = new Map(); // socketId -> user
const messages = []; // Historique des messages
const bannedIPs = new Set(); // IPs bannies

// ============================================
// Utilitaires
// ============================================
function getTimestamp() {
  return new Date().toLocaleTimeString('fr-FR', {
    hour: '2-digit',
    minute: '2-digit'
  });
}

function generateId() {
  return Date.now().toString(36) + Math.random().toString(36).substr(2);
}

function broadcastUsersList() {
  const users = Array.from(connectedUsers.values()).map(u => ({
    id: u.id,
    username: u.username,
    avatar: u.avatar,
    avatarUrl: u.avatarUrl,
    color: u.color,
    role: u.role,
    status: 'en ligne',
    ipAddress: u.ipAddress,
  }));
  io.emit('users_update', { users });
}

// ============================================
// Gestion des connexions Socket.IO
// ============================================
io.on('connection', (socket) => {
  const clientIP = socket.handshake.headers['x-forwarded-for'] ||
                   socket.handshake.address ||
                   'unknown';

  console.log(`ğŸ“¡ Nouvelle connexion: ${socket.id} (IP: ${clientIP})`);

  // VÃ©rifier si l'IP est bannie
  if (bannedIPs.has(clientIP)) {
    console.log(`ğŸš« Connexion refusÃ©e (IP bannie): ${clientIP}`);
    socket.emit('error', { message: 'Vous Ãªtes banni de ce chat.' });
    socket.disconnect(true);
    return;
  }

  // --- Rejoindre le chat ---
  socket.on('join', (userData) => {
    const user = {
      id: userData.id || generateId(),
      username: userData.username,
      avatar: userData.avatar,
      avatarUrl: userData.avatarUrl,
      color: userData.color || '#00d9c0',
      role: userData.role || 'utilisateur',
      socketId: socket.id,
      ipAddress: clientIP,
      joinedAt: new Date(),
    };

    connectedUsers.set(socket.id, user);
    console.log(`âœ… ${user.username} a rejoint le chat`);

    // Notifier tous les clients
    io.emit('user_join', {
      user: {
        id: user.id,
        username: user.username,
        avatar: user.avatar,
        avatarUrl: user.avatarUrl,
        color: user.color,
        role: user.role,
        ipAddress: user.ipAddress,
      },
      timestamp: getTimestamp(),
    });

    // Envoyer l'historique des messages au nouvel utilisateur
    socket.emit('messages_history', { messages: messages.slice(-100) });

    // Mettre Ã  jour la liste des utilisateurs
    broadcastUsersList();
  });

  // --- Envoyer un message ---
  socket.on('send_message', (data) => {
    console.log(data)
    const user = connectedUsers.get(socket.id);
    if (!user) {
      socket.emit('error', { message: 'Vous devez rejoindre le chat d\'abord.' });
      return;
    }

    const message = {
      id: generateId(),
      userId: user.id,
      username: user.username,
      content: data.content,
      timestamp: getTimestamp(),
      avatar: user.avatar,
      avatarUrl: user.avatarUrl,
      isAdmin: user.role === 'admin' || user.role === 'administrateur',
      color: user.color,
      imageUrl: data.imageUrl,
      gifUrl: data.gifUrl,
      audioUrl: data.audioUrl,
      audioDuration: data.audioDuration,
    };

    // Sauvegarder le message
    messages.push(message);
    if (messages.length > 500) {
      messages.shift(); // Garder seulement les 500 derniers messages
    }

    // Diffuser Ã  tous les clients
    io.emit('message', message);
    console.log(`ğŸ’¬ ${user.username}: ${data.content?.substring(0, 50) || '[mÃ©dia]'}`);
  });

  // --- Indicateur de frappe ---
  socket.on('typing', () => {
    const user = connectedUsers.get(socket.id);
    if (user) {
      socket.broadcast.emit('typing', {
        userId: user.id,
        username: user.username,
      });
    }
  });

  socket.on('stop_typing', () => {
    const user = connectedUsers.get(socket.id);
    if (user) {
      socket.broadcast.emit('stop_typing', {
        userId: user.id,
        username: user.username,
      });
    }
  });

  // --- Actions admin: Ã‰jecter un utilisateur ---
  socket.on('kick_user', (data) => {
    const admin = connectedUsers.get(socket.id);
    if (!admin || (admin.role !== 'admin' && admin.role !== 'administrateur')) {
      socket.emit('error', { message: 'Permission refusÃ©e.' });
      return;
    }

    // Trouver l'utilisateur Ã  Ã©jecter
    let targetSocket = null;
    for (const [sockId, user] of connectedUsers.entries()) {
      if (user.id === data.userId) {
        targetSocket = sockId;
        break;
      }
    }

    if (targetSocket) {
      const targetUser = connectedUsers.get(targetSocket);
      console.log(`âš ï¸ ${admin.username} a Ã©jectÃ© ${targetUser.username}`);

      // Notifier tout le monde
      io.emit('user_kicked', {
        userId: targetUser.id,
        username: targetUser.username,
        by: admin.username,
        reason: data.reason,
        timestamp: getTimestamp(),
      });

      // DÃ©connecter l'utilisateur
      const targetSocketObj = io.sockets.sockets.get(targetSocket);
      if (targetSocketObj) {
        targetSocketObj.emit('kicked', {
          message: `Vous avez Ã©tÃ© Ã©jectÃ© par ${admin.username}`,
          reason: data.reason
        });
        targetSocketObj.disconnect(true);
      }

      connectedUsers.delete(targetSocket);
      broadcastUsersList();
    }
  });

  // --- Actions admin: Bannir un utilisateur ---
  socket.on('ban_user', (data) => {
    const admin = connectedUsers.get(socket.id);
    if (!admin || (admin.role !== 'admin' && admin.role !== 'administrateur')) {
      socket.emit('error', { message: 'Permission refusÃ©e.' });
      return;
    }

    // Trouver l'utilisateur Ã  bannir
    let targetSocket = null;
    for (const [sockId, user] of connectedUsers.entries()) {
      if (user.id === data.userId) {
        targetSocket = sockId;
        break;
      }
    }

    if (targetSocket) {
      const targetUser = connectedUsers.get(targetSocket);
      console.log(`ğŸš« ${admin.username} a banni ${targetUser.username}`);

      // Ajouter l'IP Ã  la liste des bannis
      if (targetUser.ipAddress) {
        bannedIPs.add(targetUser.ipAddress);
      }

      // Notifier tout le monde
      io.emit('user_banned', {
        userId: targetUser.id,
        username: targetUser.username,
        by: admin.username,
        reason: data.reason,
        timestamp: getTimestamp(),
      });

      // DÃ©connecter l'utilisateur
      const targetSocketObj = io.sockets.sockets.get(targetSocket);
      if (targetSocketObj) {
        targetSocketObj.emit('banned', {
          message: `Vous avez Ã©tÃ© banni par ${admin.username}`,
          reason: data.reason
        });
        targetSocketObj.disconnect(true);
      }

      connectedUsers.delete(targetSocket);
      broadcastUsersList();
    }
  });

  // --- Effacer les messages (admin) ---
  socket.on('clear_messages', () => {
    const admin = connectedUsers.get(socket.id);
    if (!admin || (admin.role !== 'admin' && admin.role !== 'administrateur')) {
      socket.emit('error', { message: 'Permission refusÃ©e.' });
      return;
    }

    messages.length = 0;
    io.emit('clear_messages');
    console.log(`ğŸ—‘ï¸ ${admin.username} a effacÃ© tous les messages`);
  });

  // --- DÃ©connexion ---
  socket.on('disconnect', (reason) => {
    const user = connectedUsers.get(socket.id);
    if (user) {
      console.log(`ğŸ‘‹ ${user.username} s'est dÃ©connectÃ© (${reason})`);

      io.emit('user_leave', {
        userId: user.id,
        username: user.username,
        timestamp: getTimestamp(),
      });

      connectedUsers.delete(socket.id);
      broadcastUsersList();
    }
  });

  // --- Gestion des erreurs ---
  socket.on('error', (error) => {
    console.error(`âŒ Erreur socket ${socket.id}:`, error);
  });
});

// ============================================
// DÃ©marrer le serveur
// ============================================
httpServer.listen(PORT, () => {
  console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘     ğŸ™ï¸  RADIOXPLUS Chat Server             â•‘
â•‘                                            â•‘
â•‘     Port: ${PORT}                            â•‘
â•‘     URL:  http://localhost:${PORT}           â•‘
â•‘                                            â•‘
â•‘     Ã‰vÃ©nements Socket.IO:                  â•‘
â•‘     - join         : Rejoindre le chat     â•‘
â•‘     - send_message : Envoyer un message    â•‘
â•‘     - typing       : Indicateur de frappe  â•‘
â•‘     - kick_user    : Ã‰jecter (admin)       â•‘
â•‘     - ban_user     : Bannir (admin)        â•‘
â•‘     - clear_messages: Effacer (admin)      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  `);
});

// Gestion de l'arrÃªt propre
process.on('SIGTERM', () => {
  console.log('â¹ï¸  ArrÃªt du serveur...');
  io.close(() => {
    httpServer.close(() => {
      console.log('âœ… Serveur arrÃªtÃ© proprement');
      process.exit(0);
    });
  });
});
